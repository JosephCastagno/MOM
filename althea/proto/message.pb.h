// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace messaging {
class alert;
struct alertDefaultTypeInternal;
extern alertDefaultTypeInternal _alert_default_instance_;
class disconnect;
struct disconnectDefaultTypeInternal;
extern disconnectDefaultTypeInternal _disconnect_default_instance_;
class envelope;
struct envelopeDefaultTypeInternal;
extern envelopeDefaultTypeInternal _envelope_default_instance_;
class heartbeat;
struct heartbeatDefaultTypeInternal;
extern heartbeatDefaultTypeInternal _heartbeat_default_instance_;
class market;
struct marketDefaultTypeInternal;
extern marketDefaultTypeInternal _market_default_instance_;
class order;
struct orderDefaultTypeInternal;
extern orderDefaultTypeInternal _order_default_instance_;
class pulse;
struct pulseDefaultTypeInternal;
extern pulseDefaultTypeInternal _pulse_default_instance_;
class shutdown;
struct shutdownDefaultTypeInternal;
extern shutdownDefaultTypeInternal _shutdown_default_instance_;
class subscribe;
struct subscribeDefaultTypeInternal;
extern subscribeDefaultTypeInternal _subscribe_default_instance_;
class unsubscribe;
struct unsubscribeDefaultTypeInternal;
extern unsubscribeDefaultTypeInternal _unsubscribe_default_instance_;
}  // namespace messaging
PROTOBUF_NAMESPACE_OPEN
template<> ::messaging::alert* Arena::CreateMaybeMessage<::messaging::alert>(Arena*);
template<> ::messaging::disconnect* Arena::CreateMaybeMessage<::messaging::disconnect>(Arena*);
template<> ::messaging::envelope* Arena::CreateMaybeMessage<::messaging::envelope>(Arena*);
template<> ::messaging::heartbeat* Arena::CreateMaybeMessage<::messaging::heartbeat>(Arena*);
template<> ::messaging::market* Arena::CreateMaybeMessage<::messaging::market>(Arena*);
template<> ::messaging::order* Arena::CreateMaybeMessage<::messaging::order>(Arena*);
template<> ::messaging::pulse* Arena::CreateMaybeMessage<::messaging::pulse>(Arena*);
template<> ::messaging::shutdown* Arena::CreateMaybeMessage<::messaging::shutdown>(Arena*);
template<> ::messaging::subscribe* Arena::CreateMaybeMessage<::messaging::subscribe>(Arena*);
template<> ::messaging::unsubscribe* Arena::CreateMaybeMessage<::messaging::unsubscribe>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace messaging {

// ===================================================================

class envelope final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.envelope) */ {
 public:
  inline envelope() : envelope(nullptr) {}
  ~envelope() override;
  explicit constexpr envelope(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  envelope(const envelope& from);
  envelope(envelope&& from) noexcept
    : envelope() {
    *this = ::std::move(from);
  }

  inline envelope& operator=(const envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline envelope& operator=(envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const envelope& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSubscribeData = 2,
    kUnsubscribeData = 3,
    kHeartbeatData = 4,
    kMarketData = 5,
    kOrderData = 6,
    kPulseData = 7,
    kShutdownData = 9,
    kAlertData = 10,
    kDisconnectData = 11,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const envelope* internal_default_instance() {
    return reinterpret_cast<const envelope*>(
               &_envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(envelope& a, envelope& b) {
    a.Swap(&b);
  }
  inline void Swap(envelope* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(envelope* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  envelope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<envelope>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const envelope& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const envelope& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(envelope* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.envelope";
  }
  protected:
  explicit envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
    kSubscribeDataFieldNumber = 2,
    kUnsubscribeDataFieldNumber = 3,
    kHeartbeatDataFieldNumber = 4,
    kMarketDataFieldNumber = 5,
    kOrderDataFieldNumber = 6,
    kPulseDataFieldNumber = 7,
    kShutdownDataFieldNumber = 9,
    kAlertDataFieldNumber = 10,
    kDisconnectDataFieldNumber = 11,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // .messaging.subscribe subscribe_data = 2;
  bool has_subscribe_data() const;
  private:
  bool _internal_has_subscribe_data() const;
  public:
  void clear_subscribe_data();
  const ::messaging::subscribe& subscribe_data() const;
  PROTOBUF_NODISCARD ::messaging::subscribe* release_subscribe_data();
  ::messaging::subscribe* mutable_subscribe_data();
  void set_allocated_subscribe_data(::messaging::subscribe* subscribe_data);
  private:
  const ::messaging::subscribe& _internal_subscribe_data() const;
  ::messaging::subscribe* _internal_mutable_subscribe_data();
  public:
  void unsafe_arena_set_allocated_subscribe_data(
      ::messaging::subscribe* subscribe_data);
  ::messaging::subscribe* unsafe_arena_release_subscribe_data();

  // .messaging.unsubscribe unsubscribe_data = 3;
  bool has_unsubscribe_data() const;
  private:
  bool _internal_has_unsubscribe_data() const;
  public:
  void clear_unsubscribe_data();
  const ::messaging::unsubscribe& unsubscribe_data() const;
  PROTOBUF_NODISCARD ::messaging::unsubscribe* release_unsubscribe_data();
  ::messaging::unsubscribe* mutable_unsubscribe_data();
  void set_allocated_unsubscribe_data(::messaging::unsubscribe* unsubscribe_data);
  private:
  const ::messaging::unsubscribe& _internal_unsubscribe_data() const;
  ::messaging::unsubscribe* _internal_mutable_unsubscribe_data();
  public:
  void unsafe_arena_set_allocated_unsubscribe_data(
      ::messaging::unsubscribe* unsubscribe_data);
  ::messaging::unsubscribe* unsafe_arena_release_unsubscribe_data();

  // .messaging.heartbeat heartbeat_data = 4;
  bool has_heartbeat_data() const;
  private:
  bool _internal_has_heartbeat_data() const;
  public:
  void clear_heartbeat_data();
  const ::messaging::heartbeat& heartbeat_data() const;
  PROTOBUF_NODISCARD ::messaging::heartbeat* release_heartbeat_data();
  ::messaging::heartbeat* mutable_heartbeat_data();
  void set_allocated_heartbeat_data(::messaging::heartbeat* heartbeat_data);
  private:
  const ::messaging::heartbeat& _internal_heartbeat_data() const;
  ::messaging::heartbeat* _internal_mutable_heartbeat_data();
  public:
  void unsafe_arena_set_allocated_heartbeat_data(
      ::messaging::heartbeat* heartbeat_data);
  ::messaging::heartbeat* unsafe_arena_release_heartbeat_data();

  // .messaging.market market_data = 5;
  bool has_market_data() const;
  private:
  bool _internal_has_market_data() const;
  public:
  void clear_market_data();
  const ::messaging::market& market_data() const;
  PROTOBUF_NODISCARD ::messaging::market* release_market_data();
  ::messaging::market* mutable_market_data();
  void set_allocated_market_data(::messaging::market* market_data);
  private:
  const ::messaging::market& _internal_market_data() const;
  ::messaging::market* _internal_mutable_market_data();
  public:
  void unsafe_arena_set_allocated_market_data(
      ::messaging::market* market_data);
  ::messaging::market* unsafe_arena_release_market_data();

  // .messaging.order order_data = 6;
  bool has_order_data() const;
  private:
  bool _internal_has_order_data() const;
  public:
  void clear_order_data();
  const ::messaging::order& order_data() const;
  PROTOBUF_NODISCARD ::messaging::order* release_order_data();
  ::messaging::order* mutable_order_data();
  void set_allocated_order_data(::messaging::order* order_data);
  private:
  const ::messaging::order& _internal_order_data() const;
  ::messaging::order* _internal_mutable_order_data();
  public:
  void unsafe_arena_set_allocated_order_data(
      ::messaging::order* order_data);
  ::messaging::order* unsafe_arena_release_order_data();

  // .messaging.pulse pulse_data = 7;
  bool has_pulse_data() const;
  private:
  bool _internal_has_pulse_data() const;
  public:
  void clear_pulse_data();
  const ::messaging::pulse& pulse_data() const;
  PROTOBUF_NODISCARD ::messaging::pulse* release_pulse_data();
  ::messaging::pulse* mutable_pulse_data();
  void set_allocated_pulse_data(::messaging::pulse* pulse_data);
  private:
  const ::messaging::pulse& _internal_pulse_data() const;
  ::messaging::pulse* _internal_mutable_pulse_data();
  public:
  void unsafe_arena_set_allocated_pulse_data(
      ::messaging::pulse* pulse_data);
  ::messaging::pulse* unsafe_arena_release_pulse_data();

  // .messaging.shutdown shutdown_data = 9;
  bool has_shutdown_data() const;
  private:
  bool _internal_has_shutdown_data() const;
  public:
  void clear_shutdown_data();
  const ::messaging::shutdown& shutdown_data() const;
  PROTOBUF_NODISCARD ::messaging::shutdown* release_shutdown_data();
  ::messaging::shutdown* mutable_shutdown_data();
  void set_allocated_shutdown_data(::messaging::shutdown* shutdown_data);
  private:
  const ::messaging::shutdown& _internal_shutdown_data() const;
  ::messaging::shutdown* _internal_mutable_shutdown_data();
  public:
  void unsafe_arena_set_allocated_shutdown_data(
      ::messaging::shutdown* shutdown_data);
  ::messaging::shutdown* unsafe_arena_release_shutdown_data();

  // .messaging.alert alert_data = 10;
  bool has_alert_data() const;
  private:
  bool _internal_has_alert_data() const;
  public:
  void clear_alert_data();
  const ::messaging::alert& alert_data() const;
  PROTOBUF_NODISCARD ::messaging::alert* release_alert_data();
  ::messaging::alert* mutable_alert_data();
  void set_allocated_alert_data(::messaging::alert* alert_data);
  private:
  const ::messaging::alert& _internal_alert_data() const;
  ::messaging::alert* _internal_mutable_alert_data();
  public:
  void unsafe_arena_set_allocated_alert_data(
      ::messaging::alert* alert_data);
  ::messaging::alert* unsafe_arena_release_alert_data();

  // .messaging.disconnect disconnect_data = 11;
  bool has_disconnect_data() const;
  private:
  bool _internal_has_disconnect_data() const;
  public:
  void clear_disconnect_data();
  const ::messaging::disconnect& disconnect_data() const;
  PROTOBUF_NODISCARD ::messaging::disconnect* release_disconnect_data();
  ::messaging::disconnect* mutable_disconnect_data();
  void set_allocated_disconnect_data(::messaging::disconnect* disconnect_data);
  private:
  const ::messaging::disconnect& _internal_disconnect_data() const;
  ::messaging::disconnect* _internal_mutable_disconnect_data();
  public:
  void unsafe_arena_set_allocated_disconnect_data(
      ::messaging::disconnect* disconnect_data);
  ::messaging::disconnect* unsafe_arena_release_disconnect_data();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:messaging.envelope)
 private:
  class _Internal;
  void set_has_subscribe_data();
  void set_has_unsubscribe_data();
  void set_has_heartbeat_data();
  void set_has_market_data();
  void set_has_order_data();
  void set_has_pulse_data();
  void set_has_shutdown_data();
  void set_has_alert_data();
  void set_has_disconnect_data();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::messaging::subscribe* subscribe_data_;
    ::messaging::unsubscribe* unsubscribe_data_;
    ::messaging::heartbeat* heartbeat_data_;
    ::messaging::market* market_data_;
    ::messaging::order* order_data_;
    ::messaging::pulse* pulse_data_;
    ::messaging::shutdown* shutdown_data_;
    ::messaging::alert* alert_data_;
    ::messaging::disconnect* disconnect_data_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class subscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.subscribe) */ {
 public:
  inline subscribe() : subscribe(nullptr) {}
  ~subscribe() override;
  explicit constexpr subscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  subscribe(const subscribe& from);
  subscribe(subscribe&& from) noexcept
    : subscribe() {
    *this = ::std::move(from);
  }

  inline subscribe& operator=(const subscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline subscribe& operator=(subscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const subscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const subscribe* internal_default_instance() {
    return reinterpret_cast<const subscribe*>(
               &_subscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(subscribe& a, subscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(subscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(subscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  subscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<subscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const subscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const subscribe& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(subscribe* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.subscribe";
  }
  protected:
  explicit subscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // @@protoc_insertion_point(class_scope:messaging.subscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class unsubscribe final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.unsubscribe) */ {
 public:
  inline unsubscribe() : unsubscribe(nullptr) {}
  ~unsubscribe() override;
  explicit constexpr unsubscribe(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  unsubscribe(const unsubscribe& from);
  unsubscribe(unsubscribe&& from) noexcept
    : unsubscribe() {
    *this = ::std::move(from);
  }

  inline unsubscribe& operator=(const unsubscribe& from) {
    CopyFrom(from);
    return *this;
  }
  inline unsubscribe& operator=(unsubscribe&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const unsubscribe& default_instance() {
    return *internal_default_instance();
  }
  static inline const unsubscribe* internal_default_instance() {
    return reinterpret_cast<const unsubscribe*>(
               &_unsubscribe_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(unsubscribe& a, unsubscribe& b) {
    a.Swap(&b);
  }
  inline void Swap(unsubscribe* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(unsubscribe* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  unsubscribe* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<unsubscribe>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const unsubscribe& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const unsubscribe& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(unsubscribe* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.unsubscribe";
  }
  protected:
  explicit unsubscribe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
  };
  // string topic = 1;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // @@protoc_insertion_point(class_scope:messaging.unsubscribe)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class pulse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.pulse) */ {
 public:
  inline pulse() : pulse(nullptr) {}
  ~pulse() override;
  explicit constexpr pulse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  pulse(const pulse& from);
  pulse(pulse&& from) noexcept
    : pulse() {
    *this = ::std::move(from);
  }

  inline pulse& operator=(const pulse& from) {
    CopyFrom(from);
    return *this;
  }
  inline pulse& operator=(pulse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const pulse& default_instance() {
    return *internal_default_instance();
  }
  static inline const pulse* internal_default_instance() {
    return reinterpret_cast<const pulse*>(
               &_pulse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(pulse& a, pulse& b) {
    a.Swap(&b);
  }
  inline void Swap(pulse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(pulse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  pulse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<pulse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const pulse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const pulse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(pulse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.pulse";
  }
  protected:
  explicit pulse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // int64 timestamp = 1;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:messaging.pulse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class shutdown final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.shutdown) */ {
 public:
  inline shutdown() : shutdown(nullptr) {}
  ~shutdown() override;
  explicit constexpr shutdown(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  shutdown(const shutdown& from);
  shutdown(shutdown&& from) noexcept
    : shutdown() {
    *this = ::std::move(from);
  }

  inline shutdown& operator=(const shutdown& from) {
    CopyFrom(from);
    return *this;
  }
  inline shutdown& operator=(shutdown&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const shutdown& default_instance() {
    return *internal_default_instance();
  }
  static inline const shutdown* internal_default_instance() {
    return reinterpret_cast<const shutdown*>(
               &_shutdown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(shutdown& a, shutdown& b) {
    a.Swap(&b);
  }
  inline void Swap(shutdown* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(shutdown* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  shutdown* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<shutdown>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const shutdown& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const shutdown& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(shutdown* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.shutdown";
  }
  protected:
  explicit shutdown(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kToFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // string to = 1;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // string from = 2;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // @@protoc_insertion_point(class_scope:messaging.shutdown)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.heartbeat) */ {
 public:
  inline heartbeat() : heartbeat(nullptr) {}
  ~heartbeat() override;
  explicit constexpr heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  heartbeat(const heartbeat& from);
  heartbeat(heartbeat&& from) noexcept
    : heartbeat() {
    *this = ::std::move(from);
  }

  inline heartbeat& operator=(const heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline heartbeat& operator=(heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const heartbeat* internal_default_instance() {
    return reinterpret_cast<const heartbeat*>(
               &_heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(heartbeat& a, heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const heartbeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.heartbeat";
  }
  protected:
  explicit heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPulseTsFieldNumber = 1,
    kHbeatTsFieldNumber = 2,
  };
  // int64 pulse_ts = 1;
  void clear_pulse_ts();
  int64_t pulse_ts() const;
  void set_pulse_ts(int64_t value);
  private:
  int64_t _internal_pulse_ts() const;
  void _internal_set_pulse_ts(int64_t value);
  public:

  // int64 hbeat_ts = 2;
  void clear_hbeat_ts();
  int64_t hbeat_ts() const;
  void set_hbeat_ts(int64_t value);
  private:
  int64_t _internal_hbeat_ts() const;
  void _internal_set_hbeat_ts(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:messaging.heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t pulse_ts_;
  int64_t hbeat_ts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class market final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.market) */ {
 public:
  inline market() : market(nullptr) {}
  ~market() override;
  explicit constexpr market(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  market(const market& from);
  market(market&& from) noexcept
    : market() {
    *this = ::std::move(from);
  }

  inline market& operator=(const market& from) {
    CopyFrom(from);
    return *this;
  }
  inline market& operator=(market&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const market& default_instance() {
    return *internal_default_instance();
  }
  static inline const market* internal_default_instance() {
    return reinterpret_cast<const market*>(
               &_market_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(market& a, market& b) {
    a.Swap(&b);
  }
  inline void Swap(market* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(market* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  market* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<market>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const market& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const market& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(market* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.market";
  }
  protected:
  explicit market(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSymbolFieldNumber = 1,
    kTimestampFieldNumber = 3,
    kPriceFieldNumber = 2,
  };
  // string symbol = 1;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // int64 timestamp = 3;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 price = 2;
  void clear_price();
  int32_t price() const;
  void set_price(int32_t value);
  private:
  int32_t _internal_price() const;
  void _internal_set_price(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:messaging.market)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  int64_t timestamp_;
  int32_t price_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class order final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.order) */ {
 public:
  inline order() : order(nullptr) {}
  ~order() override;
  explicit constexpr order(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  order(const order& from);
  order(order&& from) noexcept
    : order() {
    *this = ::std::move(from);
  }

  inline order& operator=(const order& from) {
    CopyFrom(from);
    return *this;
  }
  inline order& operator=(order&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const order& default_instance() {
    return *internal_default_instance();
  }
  static inline const order* internal_default_instance() {
    return reinterpret_cast<const order*>(
               &_order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(order& a, order& b) {
    a.Swap(&b);
  }
  inline void Swap(order* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(order* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  order* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<order>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const order& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const order& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(order* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.order";
  }
  protected:
  explicit order(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParticipantFieldNumber = 1,
    kSymbolFieldNumber = 2,
    kPriceFieldNumber = 3,
    kQuantityFieldNumber = 4,
  };
  // string participant = 1;
  void clear_participant();
  const std::string& participant() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_participant(ArgT0&& arg0, ArgT... args);
  std::string* mutable_participant();
  PROTOBUF_NODISCARD std::string* release_participant();
  void set_allocated_participant(std::string* participant);
  private:
  const std::string& _internal_participant() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_participant(const std::string& value);
  std::string* _internal_mutable_participant();
  public:

  // string symbol = 2;
  void clear_symbol();
  const std::string& symbol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symbol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symbol();
  PROTOBUF_NODISCARD std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // int32 price = 3;
  void clear_price();
  int32_t price() const;
  void set_price(int32_t value);
  private:
  int32_t _internal_price() const;
  void _internal_set_price(int32_t value);
  public:

  // uint32 quantity = 4;
  void clear_quantity();
  uint32_t quantity() const;
  void set_quantity(uint32_t value);
  private:
  uint32_t _internal_quantity() const;
  void _internal_set_quantity(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:messaging.order)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr participant_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  int32_t price_;
  uint32_t quantity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class alert final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:messaging.alert) */ {
 public:
  inline alert() : alert(nullptr) {}
  ~alert() override;
  explicit constexpr alert(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  alert(const alert& from);
  alert(alert&& from) noexcept
    : alert() {
    *this = ::std::move(from);
  }

  inline alert& operator=(const alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline alert& operator=(alert&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const alert* internal_default_instance() {
    return reinterpret_cast<const alert*>(
               &_alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(alert& a, alert& b) {
    a.Swap(&b);
  }
  inline void Swap(alert* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(alert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  alert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<alert>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const alert& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const alert& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(alert* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.alert";
  }
  protected:
  explicit alert(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 1,
  };
  // string description = 1;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:messaging.alert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class disconnect final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:messaging.disconnect) */ {
 public:
  inline disconnect() : disconnect(nullptr) {}
  explicit constexpr disconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  disconnect(const disconnect& from);
  disconnect(disconnect&& from) noexcept
    : disconnect() {
    *this = ::std::move(from);
  }

  inline disconnect& operator=(const disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline disconnect& operator=(disconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const disconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const disconnect* internal_default_instance() {
    return reinterpret_cast<const disconnect*>(
               &_disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(disconnect& a, disconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(disconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(disconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<disconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const disconnect& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const disconnect& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "messaging.disconnect";
  }
  protected:
  explicit disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:messaging.disconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// envelope

// string topic = 1;
inline void envelope::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& envelope::topic() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void envelope::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.envelope.topic)
}
inline std::string* envelope::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.topic)
  return _s;
}
inline const std::string& envelope::_internal_topic() const {
  return topic_.Get();
}
inline void envelope::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* envelope::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* envelope::release_topic() {
  // @@protoc_insertion_point(field_release:messaging.envelope.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void envelope::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.envelope.topic)
}

// .messaging.subscribe subscribe_data = 2;
inline bool envelope::_internal_has_subscribe_data() const {
  return payload_case() == kSubscribeData;
}
inline bool envelope::has_subscribe_data() const {
  return _internal_has_subscribe_data();
}
inline void envelope::set_has_subscribe_data() {
  _oneof_case_[0] = kSubscribeData;
}
inline void envelope::clear_subscribe_data() {
  if (_internal_has_subscribe_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.subscribe_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::subscribe* envelope::release_subscribe_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.subscribe_data)
  if (_internal_has_subscribe_data()) {
    clear_has_payload();
      ::messaging::subscribe* temp = payload_.subscribe_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.subscribe_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::subscribe& envelope::_internal_subscribe_data() const {
  return _internal_has_subscribe_data()
      ? *payload_.subscribe_data_
      : reinterpret_cast< ::messaging::subscribe&>(::messaging::_subscribe_default_instance_);
}
inline const ::messaging::subscribe& envelope::subscribe_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.subscribe_data)
  return _internal_subscribe_data();
}
inline ::messaging::subscribe* envelope::unsafe_arena_release_subscribe_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.subscribe_data)
  if (_internal_has_subscribe_data()) {
    clear_has_payload();
    ::messaging::subscribe* temp = payload_.subscribe_data_;
    payload_.subscribe_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_subscribe_data(::messaging::subscribe* subscribe_data) {
  clear_payload();
  if (subscribe_data) {
    set_has_subscribe_data();
    payload_.subscribe_data_ = subscribe_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.subscribe_data)
}
inline ::messaging::subscribe* envelope::_internal_mutable_subscribe_data() {
  if (!_internal_has_subscribe_data()) {
    clear_payload();
    set_has_subscribe_data();
    payload_.subscribe_data_ = CreateMaybeMessage< ::messaging::subscribe >(GetArenaForAllocation());
  }
  return payload_.subscribe_data_;
}
inline ::messaging::subscribe* envelope::mutable_subscribe_data() {
  ::messaging::subscribe* _msg = _internal_mutable_subscribe_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.subscribe_data)
  return _msg;
}

// .messaging.unsubscribe unsubscribe_data = 3;
inline bool envelope::_internal_has_unsubscribe_data() const {
  return payload_case() == kUnsubscribeData;
}
inline bool envelope::has_unsubscribe_data() const {
  return _internal_has_unsubscribe_data();
}
inline void envelope::set_has_unsubscribe_data() {
  _oneof_case_[0] = kUnsubscribeData;
}
inline void envelope::clear_unsubscribe_data() {
  if (_internal_has_unsubscribe_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.unsubscribe_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::unsubscribe* envelope::release_unsubscribe_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.unsubscribe_data)
  if (_internal_has_unsubscribe_data()) {
    clear_has_payload();
      ::messaging::unsubscribe* temp = payload_.unsubscribe_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.unsubscribe_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::unsubscribe& envelope::_internal_unsubscribe_data() const {
  return _internal_has_unsubscribe_data()
      ? *payload_.unsubscribe_data_
      : reinterpret_cast< ::messaging::unsubscribe&>(::messaging::_unsubscribe_default_instance_);
}
inline const ::messaging::unsubscribe& envelope::unsubscribe_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.unsubscribe_data)
  return _internal_unsubscribe_data();
}
inline ::messaging::unsubscribe* envelope::unsafe_arena_release_unsubscribe_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.unsubscribe_data)
  if (_internal_has_unsubscribe_data()) {
    clear_has_payload();
    ::messaging::unsubscribe* temp = payload_.unsubscribe_data_;
    payload_.unsubscribe_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_unsubscribe_data(::messaging::unsubscribe* unsubscribe_data) {
  clear_payload();
  if (unsubscribe_data) {
    set_has_unsubscribe_data();
    payload_.unsubscribe_data_ = unsubscribe_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.unsubscribe_data)
}
inline ::messaging::unsubscribe* envelope::_internal_mutable_unsubscribe_data() {
  if (!_internal_has_unsubscribe_data()) {
    clear_payload();
    set_has_unsubscribe_data();
    payload_.unsubscribe_data_ = CreateMaybeMessage< ::messaging::unsubscribe >(GetArenaForAllocation());
  }
  return payload_.unsubscribe_data_;
}
inline ::messaging::unsubscribe* envelope::mutable_unsubscribe_data() {
  ::messaging::unsubscribe* _msg = _internal_mutable_unsubscribe_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.unsubscribe_data)
  return _msg;
}

// .messaging.heartbeat heartbeat_data = 4;
inline bool envelope::_internal_has_heartbeat_data() const {
  return payload_case() == kHeartbeatData;
}
inline bool envelope::has_heartbeat_data() const {
  return _internal_has_heartbeat_data();
}
inline void envelope::set_has_heartbeat_data() {
  _oneof_case_[0] = kHeartbeatData;
}
inline void envelope::clear_heartbeat_data() {
  if (_internal_has_heartbeat_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.heartbeat_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::heartbeat* envelope::release_heartbeat_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.heartbeat_data)
  if (_internal_has_heartbeat_data()) {
    clear_has_payload();
      ::messaging::heartbeat* temp = payload_.heartbeat_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.heartbeat_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::heartbeat& envelope::_internal_heartbeat_data() const {
  return _internal_has_heartbeat_data()
      ? *payload_.heartbeat_data_
      : reinterpret_cast< ::messaging::heartbeat&>(::messaging::_heartbeat_default_instance_);
}
inline const ::messaging::heartbeat& envelope::heartbeat_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.heartbeat_data)
  return _internal_heartbeat_data();
}
inline ::messaging::heartbeat* envelope::unsafe_arena_release_heartbeat_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.heartbeat_data)
  if (_internal_has_heartbeat_data()) {
    clear_has_payload();
    ::messaging::heartbeat* temp = payload_.heartbeat_data_;
    payload_.heartbeat_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_heartbeat_data(::messaging::heartbeat* heartbeat_data) {
  clear_payload();
  if (heartbeat_data) {
    set_has_heartbeat_data();
    payload_.heartbeat_data_ = heartbeat_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.heartbeat_data)
}
inline ::messaging::heartbeat* envelope::_internal_mutable_heartbeat_data() {
  if (!_internal_has_heartbeat_data()) {
    clear_payload();
    set_has_heartbeat_data();
    payload_.heartbeat_data_ = CreateMaybeMessage< ::messaging::heartbeat >(GetArenaForAllocation());
  }
  return payload_.heartbeat_data_;
}
inline ::messaging::heartbeat* envelope::mutable_heartbeat_data() {
  ::messaging::heartbeat* _msg = _internal_mutable_heartbeat_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.heartbeat_data)
  return _msg;
}

// .messaging.market market_data = 5;
inline bool envelope::_internal_has_market_data() const {
  return payload_case() == kMarketData;
}
inline bool envelope::has_market_data() const {
  return _internal_has_market_data();
}
inline void envelope::set_has_market_data() {
  _oneof_case_[0] = kMarketData;
}
inline void envelope::clear_market_data() {
  if (_internal_has_market_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.market_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::market* envelope::release_market_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.market_data)
  if (_internal_has_market_data()) {
    clear_has_payload();
      ::messaging::market* temp = payload_.market_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.market_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::market& envelope::_internal_market_data() const {
  return _internal_has_market_data()
      ? *payload_.market_data_
      : reinterpret_cast< ::messaging::market&>(::messaging::_market_default_instance_);
}
inline const ::messaging::market& envelope::market_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.market_data)
  return _internal_market_data();
}
inline ::messaging::market* envelope::unsafe_arena_release_market_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.market_data)
  if (_internal_has_market_data()) {
    clear_has_payload();
    ::messaging::market* temp = payload_.market_data_;
    payload_.market_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_market_data(::messaging::market* market_data) {
  clear_payload();
  if (market_data) {
    set_has_market_data();
    payload_.market_data_ = market_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.market_data)
}
inline ::messaging::market* envelope::_internal_mutable_market_data() {
  if (!_internal_has_market_data()) {
    clear_payload();
    set_has_market_data();
    payload_.market_data_ = CreateMaybeMessage< ::messaging::market >(GetArenaForAllocation());
  }
  return payload_.market_data_;
}
inline ::messaging::market* envelope::mutable_market_data() {
  ::messaging::market* _msg = _internal_mutable_market_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.market_data)
  return _msg;
}

// .messaging.order order_data = 6;
inline bool envelope::_internal_has_order_data() const {
  return payload_case() == kOrderData;
}
inline bool envelope::has_order_data() const {
  return _internal_has_order_data();
}
inline void envelope::set_has_order_data() {
  _oneof_case_[0] = kOrderData;
}
inline void envelope::clear_order_data() {
  if (_internal_has_order_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.order_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::order* envelope::release_order_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.order_data)
  if (_internal_has_order_data()) {
    clear_has_payload();
      ::messaging::order* temp = payload_.order_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.order_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::order& envelope::_internal_order_data() const {
  return _internal_has_order_data()
      ? *payload_.order_data_
      : reinterpret_cast< ::messaging::order&>(::messaging::_order_default_instance_);
}
inline const ::messaging::order& envelope::order_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.order_data)
  return _internal_order_data();
}
inline ::messaging::order* envelope::unsafe_arena_release_order_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.order_data)
  if (_internal_has_order_data()) {
    clear_has_payload();
    ::messaging::order* temp = payload_.order_data_;
    payload_.order_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_order_data(::messaging::order* order_data) {
  clear_payload();
  if (order_data) {
    set_has_order_data();
    payload_.order_data_ = order_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.order_data)
}
inline ::messaging::order* envelope::_internal_mutable_order_data() {
  if (!_internal_has_order_data()) {
    clear_payload();
    set_has_order_data();
    payload_.order_data_ = CreateMaybeMessage< ::messaging::order >(GetArenaForAllocation());
  }
  return payload_.order_data_;
}
inline ::messaging::order* envelope::mutable_order_data() {
  ::messaging::order* _msg = _internal_mutable_order_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.order_data)
  return _msg;
}

// .messaging.pulse pulse_data = 7;
inline bool envelope::_internal_has_pulse_data() const {
  return payload_case() == kPulseData;
}
inline bool envelope::has_pulse_data() const {
  return _internal_has_pulse_data();
}
inline void envelope::set_has_pulse_data() {
  _oneof_case_[0] = kPulseData;
}
inline void envelope::clear_pulse_data() {
  if (_internal_has_pulse_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.pulse_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::pulse* envelope::release_pulse_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.pulse_data)
  if (_internal_has_pulse_data()) {
    clear_has_payload();
      ::messaging::pulse* temp = payload_.pulse_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.pulse_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::pulse& envelope::_internal_pulse_data() const {
  return _internal_has_pulse_data()
      ? *payload_.pulse_data_
      : reinterpret_cast< ::messaging::pulse&>(::messaging::_pulse_default_instance_);
}
inline const ::messaging::pulse& envelope::pulse_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.pulse_data)
  return _internal_pulse_data();
}
inline ::messaging::pulse* envelope::unsafe_arena_release_pulse_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.pulse_data)
  if (_internal_has_pulse_data()) {
    clear_has_payload();
    ::messaging::pulse* temp = payload_.pulse_data_;
    payload_.pulse_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_pulse_data(::messaging::pulse* pulse_data) {
  clear_payload();
  if (pulse_data) {
    set_has_pulse_data();
    payload_.pulse_data_ = pulse_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.pulse_data)
}
inline ::messaging::pulse* envelope::_internal_mutable_pulse_data() {
  if (!_internal_has_pulse_data()) {
    clear_payload();
    set_has_pulse_data();
    payload_.pulse_data_ = CreateMaybeMessage< ::messaging::pulse >(GetArenaForAllocation());
  }
  return payload_.pulse_data_;
}
inline ::messaging::pulse* envelope::mutable_pulse_data() {
  ::messaging::pulse* _msg = _internal_mutable_pulse_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.pulse_data)
  return _msg;
}

// .messaging.shutdown shutdown_data = 9;
inline bool envelope::_internal_has_shutdown_data() const {
  return payload_case() == kShutdownData;
}
inline bool envelope::has_shutdown_data() const {
  return _internal_has_shutdown_data();
}
inline void envelope::set_has_shutdown_data() {
  _oneof_case_[0] = kShutdownData;
}
inline void envelope::clear_shutdown_data() {
  if (_internal_has_shutdown_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.shutdown_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::shutdown* envelope::release_shutdown_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.shutdown_data)
  if (_internal_has_shutdown_data()) {
    clear_has_payload();
      ::messaging::shutdown* temp = payload_.shutdown_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.shutdown_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::shutdown& envelope::_internal_shutdown_data() const {
  return _internal_has_shutdown_data()
      ? *payload_.shutdown_data_
      : reinterpret_cast< ::messaging::shutdown&>(::messaging::_shutdown_default_instance_);
}
inline const ::messaging::shutdown& envelope::shutdown_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.shutdown_data)
  return _internal_shutdown_data();
}
inline ::messaging::shutdown* envelope::unsafe_arena_release_shutdown_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.shutdown_data)
  if (_internal_has_shutdown_data()) {
    clear_has_payload();
    ::messaging::shutdown* temp = payload_.shutdown_data_;
    payload_.shutdown_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_shutdown_data(::messaging::shutdown* shutdown_data) {
  clear_payload();
  if (shutdown_data) {
    set_has_shutdown_data();
    payload_.shutdown_data_ = shutdown_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.shutdown_data)
}
inline ::messaging::shutdown* envelope::_internal_mutable_shutdown_data() {
  if (!_internal_has_shutdown_data()) {
    clear_payload();
    set_has_shutdown_data();
    payload_.shutdown_data_ = CreateMaybeMessage< ::messaging::shutdown >(GetArenaForAllocation());
  }
  return payload_.shutdown_data_;
}
inline ::messaging::shutdown* envelope::mutable_shutdown_data() {
  ::messaging::shutdown* _msg = _internal_mutable_shutdown_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.shutdown_data)
  return _msg;
}

// .messaging.alert alert_data = 10;
inline bool envelope::_internal_has_alert_data() const {
  return payload_case() == kAlertData;
}
inline bool envelope::has_alert_data() const {
  return _internal_has_alert_data();
}
inline void envelope::set_has_alert_data() {
  _oneof_case_[0] = kAlertData;
}
inline void envelope::clear_alert_data() {
  if (_internal_has_alert_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.alert_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::alert* envelope::release_alert_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.alert_data)
  if (_internal_has_alert_data()) {
    clear_has_payload();
      ::messaging::alert* temp = payload_.alert_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.alert_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::alert& envelope::_internal_alert_data() const {
  return _internal_has_alert_data()
      ? *payload_.alert_data_
      : reinterpret_cast< ::messaging::alert&>(::messaging::_alert_default_instance_);
}
inline const ::messaging::alert& envelope::alert_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.alert_data)
  return _internal_alert_data();
}
inline ::messaging::alert* envelope::unsafe_arena_release_alert_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.alert_data)
  if (_internal_has_alert_data()) {
    clear_has_payload();
    ::messaging::alert* temp = payload_.alert_data_;
    payload_.alert_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_alert_data(::messaging::alert* alert_data) {
  clear_payload();
  if (alert_data) {
    set_has_alert_data();
    payload_.alert_data_ = alert_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.alert_data)
}
inline ::messaging::alert* envelope::_internal_mutable_alert_data() {
  if (!_internal_has_alert_data()) {
    clear_payload();
    set_has_alert_data();
    payload_.alert_data_ = CreateMaybeMessage< ::messaging::alert >(GetArenaForAllocation());
  }
  return payload_.alert_data_;
}
inline ::messaging::alert* envelope::mutable_alert_data() {
  ::messaging::alert* _msg = _internal_mutable_alert_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.alert_data)
  return _msg;
}

// .messaging.disconnect disconnect_data = 11;
inline bool envelope::_internal_has_disconnect_data() const {
  return payload_case() == kDisconnectData;
}
inline bool envelope::has_disconnect_data() const {
  return _internal_has_disconnect_data();
}
inline void envelope::set_has_disconnect_data() {
  _oneof_case_[0] = kDisconnectData;
}
inline void envelope::clear_disconnect_data() {
  if (_internal_has_disconnect_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.disconnect_data_;
    }
    clear_has_payload();
  }
}
inline ::messaging::disconnect* envelope::release_disconnect_data() {
  // @@protoc_insertion_point(field_release:messaging.envelope.disconnect_data)
  if (_internal_has_disconnect_data()) {
    clear_has_payload();
      ::messaging::disconnect* temp = payload_.disconnect_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.disconnect_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::messaging::disconnect& envelope::_internal_disconnect_data() const {
  return _internal_has_disconnect_data()
      ? *payload_.disconnect_data_
      : reinterpret_cast< ::messaging::disconnect&>(::messaging::_disconnect_default_instance_);
}
inline const ::messaging::disconnect& envelope::disconnect_data() const {
  // @@protoc_insertion_point(field_get:messaging.envelope.disconnect_data)
  return _internal_disconnect_data();
}
inline ::messaging::disconnect* envelope::unsafe_arena_release_disconnect_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:messaging.envelope.disconnect_data)
  if (_internal_has_disconnect_data()) {
    clear_has_payload();
    ::messaging::disconnect* temp = payload_.disconnect_data_;
    payload_.disconnect_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void envelope::unsafe_arena_set_allocated_disconnect_data(::messaging::disconnect* disconnect_data) {
  clear_payload();
  if (disconnect_data) {
    set_has_disconnect_data();
    payload_.disconnect_data_ = disconnect_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:messaging.envelope.disconnect_data)
}
inline ::messaging::disconnect* envelope::_internal_mutable_disconnect_data() {
  if (!_internal_has_disconnect_data()) {
    clear_payload();
    set_has_disconnect_data();
    payload_.disconnect_data_ = CreateMaybeMessage< ::messaging::disconnect >(GetArenaForAllocation());
  }
  return payload_.disconnect_data_;
}
inline ::messaging::disconnect* envelope::mutable_disconnect_data() {
  ::messaging::disconnect* _msg = _internal_mutable_disconnect_data();
  // @@protoc_insertion_point(field_mutable:messaging.envelope.disconnect_data)
  return _msg;
}

inline bool envelope::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void envelope::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline envelope::PayloadCase envelope::payload_case() const {
  return envelope::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// subscribe

// string topic = 1;
inline void subscribe::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& subscribe::topic() const {
  // @@protoc_insertion_point(field_get:messaging.subscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void subscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.subscribe.topic)
}
inline std::string* subscribe::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:messaging.subscribe.topic)
  return _s;
}
inline const std::string& subscribe::_internal_topic() const {
  return topic_.Get();
}
inline void subscribe::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* subscribe::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* subscribe::release_topic() {
  // @@protoc_insertion_point(field_release:messaging.subscribe.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void subscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.subscribe.topic)
}

// -------------------------------------------------------------------

// unsubscribe

// string topic = 1;
inline void unsubscribe::clear_topic() {
  topic_.ClearToEmpty();
}
inline const std::string& unsubscribe::topic() const {
  // @@protoc_insertion_point(field_get:messaging.unsubscribe.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void unsubscribe::set_topic(ArgT0&& arg0, ArgT... args) {
 
 topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.unsubscribe.topic)
}
inline std::string* unsubscribe::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:messaging.unsubscribe.topic)
  return _s;
}
inline const std::string& unsubscribe::_internal_topic() const {
  return topic_.Get();
}
inline void unsubscribe::_internal_set_topic(const std::string& value) {
  
  topic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* unsubscribe::_internal_mutable_topic() {
  
  return topic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* unsubscribe::release_topic() {
  // @@protoc_insertion_point(field_release:messaging.unsubscribe.topic)
  return topic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void unsubscribe::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  topic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (topic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    topic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.unsubscribe.topic)
}

// -------------------------------------------------------------------

// pulse

// int64 timestamp = 1;
inline void pulse::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t pulse::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t pulse::timestamp() const {
  // @@protoc_insertion_point(field_get:messaging.pulse.timestamp)
  return _internal_timestamp();
}
inline void pulse::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void pulse::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:messaging.pulse.timestamp)
}

// -------------------------------------------------------------------

// shutdown

// string to = 1;
inline void shutdown::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& shutdown::to() const {
  // @@protoc_insertion_point(field_get:messaging.shutdown.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void shutdown::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.shutdown.to)
}
inline std::string* shutdown::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:messaging.shutdown.to)
  return _s;
}
inline const std::string& shutdown::_internal_to() const {
  return to_.Get();
}
inline void shutdown::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* shutdown::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* shutdown::release_to() {
  // @@protoc_insertion_point(field_release:messaging.shutdown.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void shutdown::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.shutdown.to)
}

// string from = 2;
inline void shutdown::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& shutdown::from() const {
  // @@protoc_insertion_point(field_get:messaging.shutdown.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void shutdown::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.shutdown.from)
}
inline std::string* shutdown::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:messaging.shutdown.from)
  return _s;
}
inline const std::string& shutdown::_internal_from() const {
  return from_.Get();
}
inline void shutdown::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* shutdown::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* shutdown::release_from() {
  // @@protoc_insertion_point(field_release:messaging.shutdown.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void shutdown::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.shutdown.from)
}

// -------------------------------------------------------------------

// heartbeat

// int64 pulse_ts = 1;
inline void heartbeat::clear_pulse_ts() {
  pulse_ts_ = int64_t{0};
}
inline int64_t heartbeat::_internal_pulse_ts() const {
  return pulse_ts_;
}
inline int64_t heartbeat::pulse_ts() const {
  // @@protoc_insertion_point(field_get:messaging.heartbeat.pulse_ts)
  return _internal_pulse_ts();
}
inline void heartbeat::_internal_set_pulse_ts(int64_t value) {
  
  pulse_ts_ = value;
}
inline void heartbeat::set_pulse_ts(int64_t value) {
  _internal_set_pulse_ts(value);
  // @@protoc_insertion_point(field_set:messaging.heartbeat.pulse_ts)
}

// int64 hbeat_ts = 2;
inline void heartbeat::clear_hbeat_ts() {
  hbeat_ts_ = int64_t{0};
}
inline int64_t heartbeat::_internal_hbeat_ts() const {
  return hbeat_ts_;
}
inline int64_t heartbeat::hbeat_ts() const {
  // @@protoc_insertion_point(field_get:messaging.heartbeat.hbeat_ts)
  return _internal_hbeat_ts();
}
inline void heartbeat::_internal_set_hbeat_ts(int64_t value) {
  
  hbeat_ts_ = value;
}
inline void heartbeat::set_hbeat_ts(int64_t value) {
  _internal_set_hbeat_ts(value);
  // @@protoc_insertion_point(field_set:messaging.heartbeat.hbeat_ts)
}

// -------------------------------------------------------------------

// market

// string symbol = 1;
inline void market::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& market::symbol() const {
  // @@protoc_insertion_point(field_get:messaging.market.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void market::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.market.symbol)
}
inline std::string* market::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:messaging.market.symbol)
  return _s;
}
inline const std::string& market::_internal_symbol() const {
  return symbol_.Get();
}
inline void market::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* market::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* market::release_symbol() {
  // @@protoc_insertion_point(field_release:messaging.market.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void market::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.market.symbol)
}

// int32 price = 2;
inline void market::clear_price() {
  price_ = 0;
}
inline int32_t market::_internal_price() const {
  return price_;
}
inline int32_t market::price() const {
  // @@protoc_insertion_point(field_get:messaging.market.price)
  return _internal_price();
}
inline void market::_internal_set_price(int32_t value) {
  
  price_ = value;
}
inline void market::set_price(int32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:messaging.market.price)
}

// int64 timestamp = 3;
inline void market::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t market::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t market::timestamp() const {
  // @@protoc_insertion_point(field_get:messaging.market.timestamp)
  return _internal_timestamp();
}
inline void market::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void market::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:messaging.market.timestamp)
}

// -------------------------------------------------------------------

// order

// string participant = 1;
inline void order::clear_participant() {
  participant_.ClearToEmpty();
}
inline const std::string& order::participant() const {
  // @@protoc_insertion_point(field_get:messaging.order.participant)
  return _internal_participant();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void order::set_participant(ArgT0&& arg0, ArgT... args) {
 
 participant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.order.participant)
}
inline std::string* order::mutable_participant() {
  std::string* _s = _internal_mutable_participant();
  // @@protoc_insertion_point(field_mutable:messaging.order.participant)
  return _s;
}
inline const std::string& order::_internal_participant() const {
  return participant_.Get();
}
inline void order::_internal_set_participant(const std::string& value) {
  
  participant_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* order::_internal_mutable_participant() {
  
  return participant_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* order::release_participant() {
  // @@protoc_insertion_point(field_release:messaging.order.participant)
  return participant_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void order::set_allocated_participant(std::string* participant) {
  if (participant != nullptr) {
    
  } else {
    
  }
  participant_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), participant,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (participant_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    participant_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.order.participant)
}

// string symbol = 2;
inline void order::clear_symbol() {
  symbol_.ClearToEmpty();
}
inline const std::string& order::symbol() const {
  // @@protoc_insertion_point(field_get:messaging.order.symbol)
  return _internal_symbol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void order::set_symbol(ArgT0&& arg0, ArgT... args) {
 
 symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.order.symbol)
}
inline std::string* order::mutable_symbol() {
  std::string* _s = _internal_mutable_symbol();
  // @@protoc_insertion_point(field_mutable:messaging.order.symbol)
  return _s;
}
inline const std::string& order::_internal_symbol() const {
  return symbol_.Get();
}
inline void order::_internal_set_symbol(const std::string& value) {
  
  symbol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* order::_internal_mutable_symbol() {
  
  return symbol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* order::release_symbol() {
  // @@protoc_insertion_point(field_release:messaging.order.symbol)
  return symbol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void order::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    
  } else {
    
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (symbol_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.order.symbol)
}

// int32 price = 3;
inline void order::clear_price() {
  price_ = 0;
}
inline int32_t order::_internal_price() const {
  return price_;
}
inline int32_t order::price() const {
  // @@protoc_insertion_point(field_get:messaging.order.price)
  return _internal_price();
}
inline void order::_internal_set_price(int32_t value) {
  
  price_ = value;
}
inline void order::set_price(int32_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:messaging.order.price)
}

// uint32 quantity = 4;
inline void order::clear_quantity() {
  quantity_ = 0u;
}
inline uint32_t order::_internal_quantity() const {
  return quantity_;
}
inline uint32_t order::quantity() const {
  // @@protoc_insertion_point(field_get:messaging.order.quantity)
  return _internal_quantity();
}
inline void order::_internal_set_quantity(uint32_t value) {
  
  quantity_ = value;
}
inline void order::set_quantity(uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:messaging.order.quantity)
}

// -------------------------------------------------------------------

// alert

// string description = 1;
inline void alert::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& alert::description() const {
  // @@protoc_insertion_point(field_get:messaging.alert.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void alert::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:messaging.alert.description)
}
inline std::string* alert::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:messaging.alert.description)
  return _s;
}
inline const std::string& alert::_internal_description() const {
  return description_.Get();
}
inline void alert::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* alert::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* alert::release_description() {
  // @@protoc_insertion_point(field_release:messaging.alert.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void alert::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:messaging.alert.description)
}

// -------------------------------------------------------------------

// disconnect

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace messaging

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
